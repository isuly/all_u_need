# all_u_need
Questions u can meet on Python interview


### Patterns

###### 1. Основные группы паттернов

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  
1)Порождающие

Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.

2)Структурные

Отвечают за построение удобных в поддержке иерархий классов.

3)Поведенческие

Решают задачи эффективного и безопасного взаимодействия между объектами программы.

</p>
</details>

###### 2. Порождающие

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  
  ###### 2.1 Фабричный метод

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
  
  Пример с логистикой: Общие методы логистики, но разные ТС: морская и дорожная логистика.
  Например, классы Грузовик и Судно реализуют интерфейс Транспорт с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе ДорожнойЛогистики вернёт объект-грузовик, а класс МорскойЛогистики — объект-судно.
  
  
  Когда надо применять паттерн

    Когда заранее неизвестно, объекты каких типов необходимо создавать
    Когда нужно управлять разными типами объектов
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.

    abstract class Product
    {}

    class ConcreteProductA : Product
    {}

    class ConcreteProductB : Product
    {}

    abstract class Creator
    {
        public abstract Product FactoryMethod();
    }

    class ConcreteCreatorA : Creator
    {
        public override Product FactoryMethod() { return new ConcreteProductA(); }
    }

    class ConcreteCreatorB : Creator
    {
        public override Product FactoryMethod() { return new ConcreteProductB(); }
    }

Преимущества

    Избавляет класс от привязки к конкретным классам продуктов.
    Выделяет код производства продуктов в одно место, упрощая поддержку кода.
    Упрощает добавление новых продуктов в программу.
    Реализует принцип открытости/закрытости.

 и недостатки
 
    Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.



</p>
</details>

  ###### 2.2 Абстрактная фабрика

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 2.3 Строитель

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 2.4 Прототип

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 2.5 Одиночка

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
  
  Одиночка:
  Гарантирует наличие единственного экземпляра класса. 
  Предоставляет глобальную точку доступа.
  
  Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.
  
  Преимущества

    Гарантирует наличие единственного экземпляра класса.
    Предоставляет к нему глобальную точку доступа.
    Реализует отложенную инициализацию объекта-одиночки.

 и недостатки
 
    Нарушает принцип единственной ответственности класса.
    Маскирует плохой дизайн.
    Проблемы мультипоточности.
    Требует постоянного создания Mock-объектов при юнит-тестировании.



</p>
</details>


</p>
</details>
