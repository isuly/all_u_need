# all_u_need
Questions u can meet on Python interview


### Patterns


###### 1. REST

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  REST (от англ. Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.
  
  Когда использовать REST?

• Когда есть ограничение пропускной способности соединения
• Если необходимо кэшировать запросы
• Если система предполагает значительное масштабирование
• В сервисах, использующих AJAX

Что такое RESTful:

Чтобы распределенная система считалась сконструированной по REST архитектуре (Restful), необходимо, чтобы она удовлетворяла следующим критериям:

    Client-Server. Система должна быть разделена на клиентов и на серверов. Разделение интерфейсов означает, что, например, клиенты не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется.
    Stateless. Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента.
    Cache․ Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.
    Uniform Interface. Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно.
    Layered System. В REST допускается разделить систему на иерархию слоев но с условием, что каждый компонент может видеть компоненты только непосредственно следующего слоя. Например, если вы вызывайте службу PayPal а он в свою очередь вызывает службу Visa, вы о вызове службы Visa ничего не должны знать.
    Code-On-Demand (опционально). В REST позволяется загрузка и выполнение кода или программы на стороне клиента.

Серверы могут временно расширять или кастомизировать функционал клиента, передавая ему логику, которую он может исполнять.


</p>
</details>


###### 2. Основные группы паттернов

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  
1)Порождающие

Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.

2)Структурные

Отвечают за построение удобных в поддержке иерархий классов.

3)Поведенческие

Решают задачи эффективного и безопасного взаимодействия между объектами программы.

</p>
</details>

###### 3. Порождающие

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  
  ###### 3.1 Фабричный метод

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
  
  Пример с логистикой: Общие методы логистики, но разные ТС: морская и дорожная логистика.
  Например, классы Грузовик и Судно реализуют интерфейс Транспорт с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе ДорожнойЛогистики вернёт объект-грузовик, а класс МорскойЛогистики — объект-судно.
  
  
  Когда надо применять паттерн

    Когда заранее неизвестно, объекты каких типов необходимо создавать
    Когда нужно управлять разными типами объектов
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.

    abstract class Product
    {}

    class ConcreteProductA : Product
    {}

    class ConcreteProductB : Product
    {}

    abstract class Creator
    {
        public abstract Product FactoryMethod();
    }

    class ConcreteCreatorA : Creator
    {
        public override Product FactoryMethod() { return new ConcreteProductA(); }
    }

    class ConcreteCreatorB : Creator
    {
        public override Product FactoryMethod() { return new ConcreteProductB(); }
    }

Преимущества

    Избавляет класс от привязки к конкретным классам продуктов.
    Выделяет код производства продуктов в одно место, упрощая поддержку кода.
    Упрощает добавление новых продуктов в программу.
    Реализует принцип открытости/закрытости.

 и недостатки
 
    Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.



</p>
</details>

  ###### 3.2 Абстрактная фабрика

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 3.3 Строитель

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 3.4 Прототип

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  


</p>
</details>

  ###### 3.5 Одиночка

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
  
  Одиночка:
  Гарантирует наличие единственного экземпляра класса. 
  Предоставляет глобальную точку доступа.
  
  Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.
  
  Преимущества

    Гарантирует наличие единственного экземпляра класса.
    Предоставляет к нему глобальную точку доступа.
    Реализует отложенную инициализацию объекта-одиночки.

 и недостатки
 
    Нарушает принцип единственной ответственности класса.
    Маскирует плохой дизайн.
    Проблемы мультипоточности.
    Требует постоянного создания Mock-объектов при юнит-тестировании.



</p>
</details>


</p>
</details>
