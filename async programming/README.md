# all_u_need
Questions u can meet on Python interview


###### 1. Потокобезопасная функция

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

Потокобезопасная функция может быть вызвана одновременно из разных потоков, даже когда вызовы используют разделяемые данные, поскольку все обращения к разделяемым данным упорядочены.
Реентерабельная функция также может быть вызвана одновременно из нескольких потоков, но только если каждый вызов использует свои собственные данные.

Таким образом, потокобезопасная функция всегда реентерабельна, но реентерабельная функция не всегда потокобезопасна.
</p>
</details>

###### 2. Как в питоне реализуется многопоточность? Какие модули?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Многопоточность достигается модулем Threading. Это нативные Posix-треды. Такие треды исполняются операционной системой, а не виртуальной машиной.

</p>
</details>

###### 3. Что такое GIL? Как работает? Какие проблемы?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Global Interpreter Lock. Особенность интерпретатора, когда одновременно может исполняться только один тред. Все это время остальные треды простаивают. GIL есть не только в Питоне, но и в других скриптовых языках, например, Руби.

Причина существования GIL в том, что для этих интерпретаторов еще не найден безопасный способ согласовывать изменения данных. Например, если один тред удалит все элемены из списка, а второй начнет итерацию по нему, гарантированно произойдет ошибка.

GIL работает так: на каждый тред выделяется некоторый квант времени. Он измеряется в машинных единицах “тиках” и по умолчанию равен 100. Как только на тред было потрачено 100 тиков, интерпретатор бросает этот тред и переключается на второй, тратит 100 тактов на него, затем третий, и так по кругу. Этот алгоритм гарантрует, что всем тредам будет выделено ресурсов поравну.

Проблема в том, что из-за GIL далеко не все задачи могут быть решены в тредах. Напротив, их использование чаще всего снижает быстродействие программы. С использованием тредов требуется следить за доступом к общим ресурсам: словарям, файлам, соединением к БД.

</p>
</details>


###### 4. В чем отличие тредов от мультипроцессинга?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Главное отличие в разделении памяти. Процессы независимы друг от друга, имеют раздельные адресные пространства, идентификаторы, ресурсы. Треды исполняются в совместном адресном пространстве, имеют общий доступ к памяти, переменным, загруженным модулям.

</p>
</details>


###### 5. Какие задачи хорошо параллелятся, какие плохо?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
хорошо ложатся на треды задачи по работе с сетью. Например, выкачать сто урлов. Полученные данные обрабатывайте вне тредов.

</p>
</details>

###### 6. Нужно посчитать 100 уравнений. Делать это в тредах или нет?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Нет, потому что в этой задаче нет ввода-вывода. Интерпретатор только будет тратить лишнее время на переключение тредов. Сложные математические задачи лучше выносить в отдельные процессы, либо использовать фреймворк для распределенных задач Celery, либо подключать как C-библиотеки.

</p>
</details>

###### 7. Что такое гринлеты? Общее понятие.

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Greenlet == Green thread == Зеленые треды == легковесные треды внутри виртуальной машины. Могут называться корутинами, сопроцессами, акторами и т.д. в зависимости от платформы. Операционная система не видит их. С точки зрения ОС запущен один процесс виртуальной машины, а что внутри нее – неизвестно. Такими тредами управляет сама вируальная машина: порождает, исполняет, согласует доступ к ресурсам.

</p>
</details>
