# all_u_need
Questions u can meet on Python interview

PYTHON

###### 1. Замыкание

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
  <p>
Замыкание (closure), это такая функция, которая ссылается на локальные переменные (использует их в своём теле) в области видимости, в котток я орой она была создана. Этим замыкание отличается от обычной функции, которая может использовать только свои аргументы и глобальные переменные.
  </p>
def mul(a):
  def helper(b):
    return a * b
  return helper
  <p>
<b> Local </b>
  
Эту область видимости имеют переменные, которые создаются и используются внутри функций.

<b> Enclosing</b> 
  
Суть данной области видимости в том, что внутри функции могут быть вложенные функции и локальные переменные, так вот локальная переменная функции для ее вложенной функции находится в enclosing области видимости.

<b> Global</b> 

Переменные области видимости global – это глобальные переменные уровня модуля

<b> Built-in</b> 

Уровень Python интерпретатора. В рамках этой области видимости находятся функции open, len и т.п., также туда входят исключения. Эти сущности доступны в любом модуле Python и не требуют предварительного импорта. Built-in – это максимально широкая область видимости.
</p>
</p>
</details>


###### 2. Декоратор

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:
Декораторы — это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.
Декоратор:

      def wraper(func):
          def wrapper():
              print('1')
              func()
              print('3')
          return wrapper

      @wraper
      def decorated_func():
          print('2')


      Декоратор с параметром:
      def parametr_decorator(param: str):
          def decorator(func):
              def new_func():
                  print('1')
                  func()
                  print('3')
              return new_func
          print(param)
          return decorator


      @parametr_decorator('parametr')
      def decorated():
          print('2')

</p>
</details>

###### 3. Генератор/итератор

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 4. Send/Throw/Close в генераторе

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 5. Множественное наследование + mro

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 6. Интерфейс/абстрактный класс

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 7. Метаклассы

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 8. Сравнение объектов

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 9. Отличие staticmethod от classmethod

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 10. Property

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 11. Изменяемые/Неизменяемые типы

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 12. Как удалить повторяющиеся элементы из списка

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 13. Тернарный оператор

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>


###### 14. Лист/Дикт комприхейшн

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 15. Классы mixins

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

</p>
</details>

###### 16. Где быстрее поиск элемента — в списке или множестве?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

Во множестве, потому что множество работает как словарь. Значение ищется по хешу ключа. Вычисление хеша и сопоставление адреса – операции постоянной сложности, поэтому принято говорить, что поиск в словаре равен O(1).

Исключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.

</p>

###### 17. Что такое *args, **kwargs, в каких случаях они требуются?

<details><summary><b>Ответ</b></summary>
<p>

#### Ответ:

Выражения *args и ** kwargs объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами args и kwargs (без звездочек). Можно использовать другие имена, но это считается дурным тоном.

args – это кортеж, который накапливает позиционные аргументы. kwargs – словарь позиционных аргументов, где ключ – имя параметра, значение – значение параметра.

Важно: если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не None.
</p>
</details>
